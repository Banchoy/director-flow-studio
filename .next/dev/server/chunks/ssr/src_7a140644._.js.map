{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lenovo/Downloads/director-flow-studio/src/lib/db.ts"],"sourcesContent":["/**\r\n * Prisma Client — DirectorFlow\r\n *\r\n * Instancia o Prisma Client com o driver adapter do Turso (LibSQL).\r\n * Usa singleton pattern para evitar múltiplas conexões em desenvolvimento.\r\n *\r\n * Em produção (Vercel Edge Runtime), cria uma nova instância por request.\r\n */\r\nimport { PrismaClient } from '@prisma/client'\r\nimport { PrismaLibSql } from '@prisma/adapter-libsql'\r\nimport { createClient } from '@libsql/client'\r\n\r\ndeclare global {\r\n  // eslint-disable-next-line no-var\r\n  var __prisma: PrismaClient | undefined\r\n}\r\n\r\nfunction createPrismaClient(): PrismaClient {\r\n  const libsql = createClient({\r\n    url: process.env.TURSO_DATABASE_URL!,\r\n    authToken: process.env.TURSO_AUTH_TOKEN ?? '',\r\n  })\r\n\r\n  const adapter = new PrismaLibSql(libsql)\r\n\r\n  return new PrismaClient({ adapter } as ConstructorParameters<typeof PrismaClient>[0])\r\n}\r\n\r\nexport const db: PrismaClient =\r\n  globalThis.__prisma ?? createPrismaClient()\r\n\r\nif (process.env.NODE_ENV !== 'production') {\r\n  globalThis.__prisma = db\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;;;;;;;CAOC,GACD;AACA;AACA;;;;;;;;;AAOA,SAAS;IACP,MAAM,SAAS,IAAA,6MAAY,EAAC;QAC1B,KAAK,QAAQ,GAAG,CAAC,kBAAkB;QACnC,WAAW,QAAQ,GAAG,CAAC,gBAAgB,IAAI;IAC7C;IAEA,MAAM,UAAU,IAAI,uLAAY,CAAC;IAEjC,OAAO,IAAI,sMAAY,CAAC;QAAE;IAAQ;AACpC;AAEO,MAAM,KACX,WAAW,QAAQ,IAAI;AAEzB,wCAA2C;IACzC,WAAW,QAAQ,GAAG;AACxB"}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lenovo/Downloads/director-flow-studio/src/app/actions/settings.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { auth } from \"@clerk/nextjs/server\";\r\nimport { prisma } from \"@/lib/db\";\r\nimport { revalidatePath } from \"next/cache\";\r\n\r\nexport async function saveSettings(formData: FormData) {\r\n    const { userId } = await auth();\r\n\r\n    if (!userId) {\r\n        throw new Error(\"Usuário não autenticado\");\r\n    }\r\n\r\n    const deepseekKey = formData.get(\"deepseekKey\") as string;\r\n    const leonardoKey = formData.get(\"leonardoKey\") as string;\r\n    const elevenlabsKey = formData.get(\"elevenlabsKey\") as string;\r\n    const lumaKey = formData.get(\"lumaKey\") as string;\r\n    const animeStyle = formData.get(\"animeStyle\") as string;\r\n    const isAnimeMode = formData.get(\"isAnimeMode\") === \"on\";\r\n\r\n    try {\r\n        // Primeiro garante que o usuário existe no nosso DB\r\n        await prisma.user.upsert({\r\n            where: { id: userId },\r\n            update: {},\r\n            create: {\r\n                id: userId,\r\n                email: \"placeholder@clerk.user\" // O Clerk gerencia o email, usamos placeholder ou pegamos via API se necessário\r\n            },\r\n        });\r\n\r\n        // Salva ou atualiza as configurações\r\n        await prisma.setting.upsert({\r\n            where: { userId },\r\n            update: {\r\n                deepseekKey,\r\n                leonardoKey,\r\n                elevenlabsKey,\r\n                lumaKey,\r\n                animeStyle,\r\n                isAnimeMode,\r\n            },\r\n            create: {\r\n                userId,\r\n                deepseekKey,\r\n                leonardoKey,\r\n                elevenlabsKey,\r\n                lumaKey,\r\n                animeStyle,\r\n                isAnimeMode,\r\n            },\r\n        });\r\n\r\n        revalidatePath(\"/settings\");\r\n        revalidatePath(\"/\");\r\n\r\n        return { success: true };\r\n    } catch (error) {\r\n        console.error(\"Erro ao salvar configurações:\", error);\r\n        return { success: false, error: \"Falha ao salvar no banco de dados.\" };\r\n    }\r\n}\r\n\r\nexport async function getSettings() {\r\n    const { userId } = await auth();\r\n    if (!userId) return null;\r\n\r\n    return await prisma.setting.findUnique({\r\n        where: { userId },\r\n    });\r\n}\r\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;;;;;;;;;;AAEO,eAAe,aAAa,QAAkB;IACjD,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,IAAA,2LAAI;IAE7B,IAAI,CAAC,QAAQ;QACT,MAAM,IAAI,MAAM;IACpB;IAEA,MAAM,cAAc,SAAS,GAAG,CAAC;IACjC,MAAM,cAAc,SAAS,GAAG,CAAC;IACjC,MAAM,gBAAgB,SAAS,GAAG,CAAC;IACnC,MAAM,UAAU,SAAS,GAAG,CAAC;IAC7B,MAAM,aAAa,SAAS,GAAG,CAAC;IAChC,MAAM,cAAc,SAAS,GAAG,CAAC,mBAAmB;IAEpD,IAAI;QACA,oDAAoD;QACpD,MAAM,0HAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YACrB,OAAO;gBAAE,IAAI;YAAO;YACpB,QAAQ,CAAC;YACT,QAAQ;gBACJ,IAAI;gBACJ,OAAO,yBAAyB,gFAAgF;YACpH;QACJ;QAEA,qCAAqC;QACrC,MAAM,0HAAM,CAAC,OAAO,CAAC,MAAM,CAAC;YACxB,OAAO;gBAAE;YAAO;YAChB,QAAQ;gBACJ;gBACA;gBACA;gBACA;gBACA;gBACA;YACJ;YACA,QAAQ;gBACJ;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;YACJ;QACJ;QAEA,IAAA,+IAAc,EAAC;QACf,IAAA,+IAAc,EAAC;QAEf,OAAO;YAAE,SAAS;QAAK;IAC3B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO;YAAE,SAAS;YAAO,OAAO;QAAqC;IACzE;AACJ;AAEO,eAAe;IAClB,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,IAAA,2LAAI;IAC7B,IAAI,CAAC,QAAQ,OAAO;IAEpB,OAAO,MAAM,0HAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QACnC,OAAO;YAAE;QAAO;IACpB;AACJ;;;IAhEsB;IAyDA;;AAzDA,+OAAA;AAyDA,+OAAA"}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lenovo/Downloads/director-flow-studio/src/services/ia/deepseek.ts"],"sourcesContent":["/**\r\n * Serviço DeepSeek — Geração de Roteiros para DirectorFlow\r\n *\r\n * Usa a API OpenAI-compatible do DeepSeek para gerar roteiros estruturados\r\n * em JSON. Quando o Modo Anime está ativo, os prompts são ajustados para\r\n * priorizar estética visual 2D (Ghibli, Shonen, Seinen).\r\n */\r\n\r\n// --------------------------------------------------------------------------\r\n// Tipos\r\n// --------------------------------------------------------------------------\r\n\r\nexport type AnimeStyle = 'shonen' | 'seinen' | 'ghibli'\r\n\r\nexport interface ScenePrompt {\r\n    /** Número da cena (1-indexed) */\r\n    order: number\r\n    /** Descrição narrativa para diálogos/narração */\r\n    description: string\r\n    /** Prompt visual para o gerador de imagens (inglês) */\r\n    visualPrompt: string\r\n    /** Duração estimada em segundos */\r\n    durationSeconds: number\r\n    /** Tom emocional da cena */\r\n    tone: 'action' | 'dramatic' | 'peaceful' | 'comedic' | 'emotional'\r\n}\r\n\r\nexport interface GeneratedScript {\r\n    /** Título do projeto */\r\n    title: string\r\n    /** Sinopse curta */\r\n    synopsis: string\r\n    /** Estilo visual (presente apenas em Modo Anime) */\r\n    animeStyle?: AnimeStyle\r\n    /** Gênero narrativo */\r\n    genre: string\r\n    /** Lista de cenas geradas */\r\n    scenes: ScenePrompt[]\r\n}\r\n\r\nexport interface DeepSeekOptions {\r\n    /** Chave de API do usuário (BYOK) */\r\n    apiKey: string\r\n    /** Briefing do projeto fornecido pelo usuário */\r\n    briefing: string\r\n    /** Número de cenas desejadas */\r\n    sceneCount?: number\r\n    /** Se true, ativa prompts visuais focados em anime 2D */\r\n    isAnimeMode?: boolean\r\n    /** Estilo de anime quando isAnimeMode = true */\r\n    animeStyle?: AnimeStyle\r\n}\r\n\r\n// --------------------------------------------------------------------------\r\n// Constantes\r\n// --------------------------------------------------------------------------\r\n\r\nconst DEEPSEEK_BASE_URL = 'https://api.deepseek.com'\r\nconst DEFAULT_MODEL = 'deepseek-chat' // DeepSeek V3\r\n\r\n// --------------------------------------------------------------------------\r\n// Helpers\r\n// --------------------------------------------------------------------------\r\n\r\n/**\r\n * Monta o system prompt de acordo com o modo ativo.\r\n * No Modo Anime, instrui a IA a usar estética visual específica.\r\n */\r\nfunction buildSystemPrompt(isAnimeMode: boolean, animeStyle?: AnimeStyle): string {\r\n    const baseInstructions = `\r\nVocê é um diretor cinematográfico e roteirista especialista.\r\nResponda SEMPRE em formato JSON válido, seguindo exatamente o schema fornecido.\r\nNão inclua texto fora do JSON. Não use Markdown no retorno.\r\n  `.trim()\r\n\r\n    if (!isAnimeMode) {\r\n        return `${baseInstructions}\\nCrie roteiros cinematográficos realistas e cinematográficos.`\r\n    }\r\n\r\n    const styleGuides: Record<AnimeStyle, string> = {\r\n        shonen: `Estética SHONEN: ação intensa, personagens expressivos, movimentos dinâmicos, paleta vibrante, efeitos de velocidade (speed lines), expressões exageradas de emoção.`,\r\n        seinen: `Estética SEINEN: narrativa madura, tons sombrios, detalhes realistas, composição cinematográfica, paleta dessaturada com acentos contrastantes.`,\r\n        ghibli: `Estética GHIBLI (Studio Ghibli): cenários naturais exuberantes, luz suave e aquarelada, personagens charmosos e expressivos, fundo detalhado com planos abertos, atmosfera encantadora e nostálgica.`,\r\n    }\r\n\r\n    const style = animeStyle ?? 'shonen'\r\n\r\n    return `\r\n${baseInstructions}\r\n${styleGuides[style]}\r\n\r\nRegras para prompts visuais no Modo Anime:\r\n- Escreva os \"visualPrompt\" em inglês, focados em estética 2D cel-shading.\r\n- Use termos como: \"anime style\", \"2D animation\", \"key frame illustration\", \"${style} aesthetic\".\r\n- Descreva composição de câmera (close-up, wide shot, low angle) e iluminação.\r\n- Inclua referências de paleta de cores.\r\n  `.trim()\r\n}\r\n\r\n/**\r\n * Monta o schema JSON esperado para instruir a IA.\r\n */\r\nfunction buildUserPrompt(briefing: string, sceneCount: number): string {\r\n    return `\r\nCrie um roteiro completo para o seguinte projeto:\r\n\r\nBRIEFING:\r\n${briefing}\r\n\r\nRetorne um JSON com exatamente este schema:\r\n{\r\n  \"title\": \"string\",\r\n  \"synopsis\": \"string (max 2 frases)\",\r\n  \"genre\": \"string\",\r\n  \"animeStyle\": \"shonen | seinen | ghibli | null\",\r\n  \"scenes\": [\r\n    {\r\n      \"order\": number,\r\n      \"description\": \"string (narrativa, em português)\",\r\n      \"visualPrompt\": \"string (prompt para gerador de imagem, em inglês)\",\r\n      \"durationSeconds\": number,\r\n      \"tone\": \"action | dramatic | peaceful | comedic | emotional\"\r\n    }\r\n  ]\r\n}\r\n\r\nNúmero de cenas: ${sceneCount}\r\n  `.trim()\r\n}\r\n\r\n// --------------------------------------------------------------------------\r\n// Validação do JSON retornado pela IA\r\n// --------------------------------------------------------------------------\r\n\r\nfunction validateScene(scene: unknown, index: number): ScenePrompt {\r\n    if (typeof scene !== 'object' || scene === null) {\r\n        throw new Error(`Cena ${index + 1}: formato inválido (esperado objeto).`)\r\n    }\r\n\r\n    const s = scene as Record<string, unknown>\r\n\r\n    const validTones = ['action', 'dramatic', 'peaceful', 'comedic', 'emotional'] as const\r\n    const tone = s.tone as string\r\n\r\n    if (!validTones.includes(tone as (typeof validTones)[number])) {\r\n        throw new Error(`Cena ${index + 1}: \"tone\" inválido — recebido \"${tone}\".`)\r\n    }\r\n\r\n    if (typeof s.order !== 'number') throw new Error(`Cena ${index + 1}: \"order\" deve ser número.`)\r\n    if (typeof s.description !== 'string') throw new Error(`Cena ${index + 1}: \"description\" inválida.`)\r\n    if (typeof s.visualPrompt !== 'string') throw new Error(`Cena ${index + 1}: \"visualPrompt\" inválido.`)\r\n    if (typeof s.durationSeconds !== 'number') throw new Error(`Cena ${index + 1}: \"durationSeconds\" deve ser número.`)\r\n\r\n    return {\r\n        order: s.order,\r\n        description: s.description,\r\n        visualPrompt: s.visualPrompt,\r\n        durationSeconds: s.durationSeconds,\r\n        tone: tone as ScenePrompt['tone'],\r\n    }\r\n}\r\n\r\nfunction validateScript(raw: unknown): GeneratedScript {\r\n    if (typeof raw !== 'object' || raw === null) {\r\n        throw new Error('Resposta da IA não é um objeto JSON válido.')\r\n    }\r\n\r\n    const r = raw as Record<string, unknown>\r\n\r\n    if (typeof r.title !== 'string') throw new Error('Campo \"title\" ausente ou inválido.')\r\n    if (typeof r.synopsis !== 'string') throw new Error('Campo \"synopsis\" ausente ou inválido.')\r\n    if (typeof r.genre !== 'string') throw new Error('Campo \"genre\" ausente ou inválido.')\r\n    if (!Array.isArray(r.scenes)) throw new Error('Campo \"scenes\" deve ser um array.')\r\n    if (r.scenes.length === 0) throw new Error('A IA retornou 0 cenas.')\r\n\r\n    const validStyles: AnimeStyle[] = ['shonen', 'seinen', 'ghibli']\r\n    const animeStyle =\r\n        r.animeStyle && validStyles.includes(r.animeStyle as AnimeStyle)\r\n            ? (r.animeStyle as AnimeStyle)\r\n            : undefined\r\n\r\n    return {\r\n        title: r.title,\r\n        synopsis: r.synopsis,\r\n        genre: r.genre,\r\n        animeStyle,\r\n        scenes: r.scenes.map((scene, i) => validateScene(scene, i)),\r\n    }\r\n}\r\n\r\n// --------------------------------------------------------------------------\r\n// Função principal\r\n// --------------------------------------------------------------------------\r\n\r\n/**\r\n * Gera um roteiro estruturado usando a API do DeepSeek.\r\n *\r\n * @param options - Configurações do DeepSeek + briefing do projeto\r\n * @returns Roteiro validado como `GeneratedScript`\r\n * @throws Erro se a API falhar ou o JSON retornado for inválido\r\n */\r\nexport async function generateScript(options: DeepSeekOptions): Promise<GeneratedScript> {\r\n    const {\r\n        apiKey,\r\n        briefing,\r\n        sceneCount = 5,\r\n        isAnimeMode = false,\r\n        animeStyle = 'shonen',\r\n    } = options\r\n\r\n    const systemPrompt = buildSystemPrompt(isAnimeMode, animeStyle)\r\n    const userPrompt = buildUserPrompt(briefing, sceneCount)\r\n\r\n    try {\r\n        const response = await fetch(`${DEEPSEEK_BASE_URL}/chat/completions`, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                Authorization: `Bearer ${apiKey}`,\r\n            },\r\n            body: JSON.stringify({\r\n                model: DEFAULT_MODEL,\r\n                messages: [\r\n                    { role: 'system', content: systemPrompt },\r\n                    { role: 'user', content: userPrompt },\r\n                ],\r\n                response_format: { type: 'json_object' },\r\n                temperature: 0.8,\r\n                max_tokens: 4096,\r\n            }),\r\n        })\r\n\r\n        if (!response.ok) {\r\n            const errorBody = await response.text()\r\n            console.error('DeepSeek API Error:', { status: response.status, body: errorBody })\r\n            throw new Error(\r\n                `Erro na API DeepSeek (${response.status}): ${errorBody || response.statusText}`\r\n            )\r\n        }\r\n\r\n        const data = await response.json()\r\n        const content = data?.choices?.[0]?.message?.content\r\n\r\n        if (!content) {\r\n            console.error('DeepSeek Response Empty:', data)\r\n            throw new Error('O DeepSeek retornou uma resposta vazia.')\r\n        }\r\n\r\n        let parsed: unknown\r\n        try {\r\n            parsed = JSON.parse(content)\r\n        } catch (e) {\r\n            console.error('DeepSeek JSON Parse Error:', { content, error: e })\r\n            throw new Error(`O DeepSeek retornou um JSON inválido e não pôde ser processado.`)\r\n        }\r\n\r\n        return validateScript(parsed)\r\n    } catch (error) {\r\n        if (error instanceof Error) {\r\n            console.error('Error in generateScript:', error.message)\r\n            throw error\r\n        }\r\n        throw new Error('Ocorreu um erro inesperado ao gerar o roteiro com o DeepSeek.')\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lenovo/Downloads/director-flow-studio/src/services/ia/leonardo.ts"],"sourcesContent":["/**\r\n * Serviço Leonardo.ai — Geração de Frames de Anime/Vídeo\r\n *\r\n * Integra com a API REST do Leonardo.ai para geração de imagens.\r\n * Suporta modelos especializados em anime/ilustração 2D.\r\n */\r\n\r\n// --------------------------------------------------------------------------\r\n// Tipos\r\n// --------------------------------------------------------------------------\r\n\r\n/** IDs de modelos do Leonardo.ai com melhor resultado para anime/video */\r\nexport const LEONARDO_MODELS = {\r\n    /** Melhor qualidade geral - anime e realismo */\r\n    PHOENIX: 'de7d3faf-762f-48e0-b3b7-9d0ac3a3fcf4',\r\n    /** Especializado em ilustração e anime */\r\n    ANIME_XL: 'e71a1c2f-4f80-4800-934f-2c68979d1cc6',\r\n    /** Estilo Ghibli / aquarela */\r\n    KINO_XL: '1aa0f478-51be-4efd-94e8-76bfc8f533af',\r\n} as const\r\n\r\nexport type LeonardoModelId = (typeof LEONARDO_MODELS)[keyof typeof LEONARDO_MODELS]\r\n\r\nexport interface LeonardoGenerateOptions {\r\n    /** Chave de API do usuário (BYOK) */\r\n    apiKey: string\r\n    /** Prompt descritivo da imagem (inglês) */\r\n    prompt: string\r\n    /** Prompt negativo para excluir elementos indesejados */\r\n    negativePrompt?: string\r\n    /** ID do modelo a usar */\r\n    modelId?: LeonardoModelId\r\n    /** Largura da imagem (default: 1024) */\r\n    width?: number\r\n    /** Altura da imagem (default: 576) — formato 16:9 */\r\n    height?: number\r\n    /** Número de imagens a gerar (1-4) */\r\n    numImages?: number\r\n    /** Seed para reprodutibilidade (consistência de personagem) */\r\n    seed?: number\r\n    /** Nível de adesão ao prompt (1-20, default: 7) */\r\n    guidanceScale?: number\r\n    /** Número de steps de inferência (default: 30) */\r\n    inferenceSteps?: number\r\n}\r\n\r\nexport interface GeneratedFrame {\r\n    /** ID da geração no Leonardo.ai */\r\n    generationId: string\r\n    /** URL pública das imagens geradas */\r\n    imageUrls: string[]\r\n    /** Seed usada (para reprodutibilidade) */\r\n    seed: number\r\n}\r\n\r\n// --------------------------------------------------------------------------\r\n// Constantes\r\n// --------------------------------------------------------------------------\r\n\r\nconst LEONARDO_BASE_URL = 'https://cloud.leonardo.ai/api/rest/v1'\r\n\r\n/** Negative prompt padrão para anime — remove artefatos comuns */\r\nconst DEFAULT_NEGATIVE_PROMPT =\r\n    'blurry, low quality, distorted, deformed, ugly, bad anatomy, extra limbs, watermark, signature, text, border'\r\n\r\n/** Polling timeout máximo em ms */\r\nconst MAX_POLL_DURATION_MS = 90_000\r\n\r\n/** Intervalo entre polls em ms */\r\nconst POLL_INTERVAL_MS = 3_000\r\n\r\n// --------------------------------------------------------------------------\r\n// Helpers\r\n// --------------------------------------------------------------------------\r\n\r\n/**\r\n * Aguarda a geração terminar via polling da API (Leonardo é assíncrono).\r\n */\r\nasync function pollGeneration(\r\n    generationId: string,\r\n    apiKey: string,\r\n): Promise<GeneratedFrame> {\r\n    const start = Date.now()\r\n\r\n    while (Date.now() - start < MAX_POLL_DURATION_MS) {\r\n        await new Promise((r) => setTimeout(r, POLL_INTERVAL_MS))\r\n\r\n        const res = await fetch(`${LEONARDO_BASE_URL}/generations/${generationId}`, {\r\n            headers: {\r\n                Authorization: `Bearer ${apiKey}`,\r\n                Accept: 'application/json',\r\n            },\r\n        })\r\n\r\n        if (!res.ok) {\r\n            throw new Error(`Leonardo poll error ${res.status}: ${await res.text()}`)\r\n        }\r\n\r\n        const data = await res.json()\r\n        const generation = data?.generations_by_pk\r\n\r\n        if (!generation) {\r\n            throw new Error('Resposta inválida do Leonardo.ai durante polling.')\r\n        }\r\n\r\n        const status: string = generation.status\r\n\r\n        if (status === 'COMPLETE') {\r\n            const images: Array<{ url: string }> = generation.generated_images ?? []\r\n\r\n            if (images.length === 0) {\r\n                throw new Error('Geração concluída mas sem imagens retornadas.')\r\n            }\r\n\r\n            return {\r\n                generationId,\r\n                imageUrls: images.map((img) => img.url),\r\n                seed: generation.seed ?? 0,\r\n            }\r\n        }\r\n\r\n        if (status === 'FAILED') {\r\n            throw new Error(`Geração falhou no Leonardo.ai. ID: ${generationId}`)\r\n        }\r\n\r\n        // status === 'PENDING' ou 'PROCESSING' — continua polling\r\n    }\r\n\r\n    throw new Error(\r\n        `Timeout: a geração ${generationId} não foi concluída em ${MAX_POLL_DURATION_MS / 1000}s.`,\r\n    )\r\n}\r\n\r\n// --------------------------------------------------------------------------\r\n// Função principal\r\n// --------------------------------------------------------------------------\r\n\r\n/**\r\n * Gera frames de anime/vídeo usando a API do Leonardo.ai.\r\n *\r\n * Leonardo é uma API assíncrona: primeiro cria a geração,\r\n * depois faz polling até o status ser COMPLETE.\r\n *\r\n * @param options - Configurações de geração\r\n * @returns Frame(s) gerado(s) com URLs públicas\r\n * @throws Erro se a API falhar, timeout ou resposta inválida\r\n */\r\nexport async function generateFrame(\r\n    options: LeonardoGenerateOptions,\r\n): Promise<GeneratedFrame> {\r\n    const {\r\n        apiKey,\r\n        prompt,\r\n        negativePrompt = DEFAULT_NEGATIVE_PROMPT,\r\n        modelId = LEONARDO_MODELS.PHOENIX,\r\n        width = 1024,\r\n        height = 576,\r\n        numImages = 1,\r\n        seed,\r\n        guidanceScale = 7,\r\n        inferenceSteps = 30,\r\n    } = options\r\n\r\n    try {\r\n        // 1. Dispara a geração\r\n        const initiateRes = await fetch(`${LEONARDO_BASE_URL}/generations`, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                Authorization: `Bearer ${apiKey}`,\r\n            },\r\n            body: JSON.stringify({\r\n                prompt,\r\n                negative_prompt: negativePrompt,\r\n                modelId,\r\n                width,\r\n                height,\r\n                num_images: numImages,\r\n                ...(seed !== undefined && { seed }),\r\n                guidance_scale: guidanceScale,\r\n                num_inference_steps: inferenceSteps,\r\n                public: false,\r\n            }),\r\n        })\r\n\r\n        if (!initiateRes.ok) {\r\n            const errorBody = await initiateRes.text()\r\n            console.error('Leonardo API Initiation Error:', { status: initiateRes.status, body: errorBody })\r\n            throw new Error(`Erro ao iniciar geração no Leonardo.ai (${initiateRes.status}): ${errorBody || initiateRes.statusText}`)\r\n        }\r\n\r\n        const initiateData = await initiateRes.json()\r\n        const generationId: string | undefined =\r\n            initiateData?.sdGenerationJob?.generationId\r\n\r\n        if (!generationId) {\r\n            console.error('Leonardo Invalid Response (No GenerationID):', initiateData)\r\n            throw new Error('O Leonardo.ai não retornou um ID de geração válido.')\r\n        }\r\n\r\n        // 2. Aguarda a conclusão via polling\r\n        return await pollGeneration(generationId, apiKey)\r\n    } catch (error) {\r\n        if (error instanceof Error) {\r\n            console.error('Error in generateFrame:', error.message)\r\n            throw error\r\n        }\r\n        throw new Error('Ocorreu um erro inesperado ao gerar a imagem com o Leonardo.ai.')\r\n    }\r\n}\r\n\r\n/**\r\n * Gera múltiplos frames em sequência (uma cena = uma chamada).\r\n * Útil para gerar todos os frames de um roteiro.\r\n *\r\n * @param prompts - Lista de prompts visuais\r\n * @param options - Opções base compartilhadas entre as gerações\r\n * @returns Array de frames gerados, na mesma ordem dos prompts\r\n */\r\nexport async function generateFrameBatch(\r\n    prompts: string[],\r\n    options: Omit<LeonardoGenerateOptions, 'prompt'>,\r\n): Promise<GeneratedFrame[]> {\r\n    const results: GeneratedFrame[] = []\r\n\r\n    for (const prompt of prompts) {\r\n        const frame = await generateFrame({ ...options, prompt })\r\n        results.push(frame)\r\n    }\r\n\r\n    return results\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 484, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lenovo/Downloads/director-flow-studio/src/services/ia/orchestrator.ts"],"sourcesContent":["/**\r\n * Orquestrador de IA — DirectorFlow\r\n *\r\n * Coordena o fluxo completo de criação:\r\n *   1. Recebe o briefing do usuário\r\n *   2. DeepSeek gera o roteiro em JSON validado\r\n *   3. Leonardo.ai gera o frame base de cada cena\r\n *\r\n * Todas as chaves de API vêm do perfil do usuário (modelo BYOK).\r\n */\r\n\r\nimport { generateScript, type GeneratedScript, type AnimeStyle } from './deepseek'\r\nimport { generateFrame, type GeneratedFrame, LEONARDO_MODELS, type LeonardoModelId } from './leonardo'\r\n\r\n// --------------------------------------------------------------------------\r\n// Tipos de entrada/saída do Orquestrador\r\n// --------------------------------------------------------------------------\r\n\r\nexport interface OrchestratorInput {\r\n    /** Briefing livre do projeto (ideia, tema, personagens, etc.) */\r\n    briefing: string\r\n\r\n    /** Número de cenas a gerar (default: 5) */\r\n    sceneCount?: number\r\n\r\n    /** Chaves de API do usuário (BYOK) */\r\n    apiKeys: {\r\n        deepseek: string\r\n        leonardo: string\r\n    }\r\n\r\n    /** Configurações de Modo Anime */\r\n    anime?: {\r\n        enabled: boolean\r\n        style?: AnimeStyle\r\n    }\r\n\r\n    /** Opções avançadas de geração de imagem */\r\n    imageOptions?: {\r\n        /** Seed global para consistência visual entre frames */\r\n        seed?: number\r\n        /** Resolução (default: 1024x576 = 16:9) */\r\n        width?: number\r\n        height?: number\r\n    }\r\n}\r\n\r\n/** Status de uma cena durante a geração */\r\nexport type SceneStatus = 'pending' | 'script_done' | 'frame_done' | 'error'\r\n\r\nexport interface SceneResult {\r\n    /** Número da cena */\r\n    order: number\r\n    /** Descrição narrativa (do roteiro) */\r\n    description: string\r\n    /** Prompt visual enviado ao Leonardo */\r\n    visualPrompt: string\r\n    /** Tom emocional */\r\n    tone: string\r\n    /** Duração estimada em segundos */\r\n    durationSeconds: number\r\n    /** Status de geração desta cena */\r\n    status: SceneStatus\r\n    /** Frame gerado (disponível quando status = 'frame_done') */\r\n    frame?: GeneratedFrame\r\n    /** Mensagem de erro, se houver */\r\n    error?: string\r\n}\r\n\r\nexport interface OrchestratorResult {\r\n    /** Se o fluxo concluiu sem erros críticos */\r\n    success: boolean\r\n    /** Metadados do roteiro gerado */\r\n    script: GeneratedScript\r\n    /** Resultados por cena (roteiro + frame) */\r\n    scenes: SceneResult[]\r\n    /** Cenas que falharam na geração de imagem */\r\n    failedScenes: number[]\r\n    /** Duração total estimada do projeto em segundos */\r\n    totalDurationSeconds: number\r\n}\r\n\r\n// --------------------------------------------------------------------------\r\n// Helpers\r\n// --------------------------------------------------------------------------\r\n\r\n/**\r\n * Seleciona o modelo Leonardo.ai mais adequado para o estilo de anime.\r\n */\r\nfunction selectLeonardoModel(animeStyle?: AnimeStyle): LeonardoModelId {\r\n    if (!animeStyle) return LEONARDO_MODELS.PHOENIX\r\n\r\n    const modelMap: Record<AnimeStyle, LeonardoModelId> = {\r\n        shonen: LEONARDO_MODELS.ANIME_XL,\r\n        seinen: LEONARDO_MODELS.ANIME_XL,\r\n        ghibli: LEONARDO_MODELS.KINO_XL,\r\n    }\r\n\r\n    return modelMap[animeStyle]\r\n}\r\n\r\n/**\r\n * Adiciona sufixo de estilo ao prompt visual quando Modo Anime está ativo.\r\n */\r\nfunction enrichPromptForAnime(prompt: string, style?: AnimeStyle): string {\r\n    if (!style) return prompt\r\n\r\n    const suffixes: Record<AnimeStyle, string> = {\r\n        shonen:\r\n            ', anime key frame illustration, shonen style, vibrant colors, dynamic pose, cel-shading, 2D animation',\r\n        seinen:\r\n            ', anime key frame illustration, seinen style, detailed linework, muted palette, cinematic composition, 2D animation',\r\n        ghibli:\r\n            ', Studio Ghibli style, watercolor illustration, lush environment, soft lighting, warm palette, hand-drawn 2D animation',\r\n    }\r\n\r\n    return `${prompt}${suffixes[style]}`\r\n}\r\n\r\n// --------------------------------------------------------------------------\r\n// Função principal\r\n// --------------------------------------------------------------------------\r\n\r\n/**\r\n * Executa o fluxo completo de criação:\r\n * DeepSeek → roteiro em JSON → Leonardo.ai → frames das cenas\r\n *\r\n * As gerações de imagem rodam em paralelo (Promise.allSettled)\r\n * para maximizar performance sem bloquear o fluxo por falhas pontuais.\r\n *\r\n * @param input - Briefing, chaves de API e configurações\r\n * @returns Resultado completo com roteiro + frames + status por cena\r\n */\r\nexport async function runCreationFlow(\r\n    input: OrchestratorInput,\r\n): Promise<OrchestratorResult> {\r\n    const {\r\n        briefing,\r\n        sceneCount = 5,\r\n        apiKeys,\r\n        anime,\r\n        imageOptions = {},\r\n    } = input\r\n\r\n    try {\r\n        const isAnimeMode = anime?.enabled ?? false\r\n        const animeStyle = isAnimeMode ? (anime?.style ?? 'shonen') : undefined\r\n\r\n        console.info('Starting creation flow...', { sceneCount, isAnimeMode, animeStyle })\r\n\r\n        // ------------------------------------------------------------------\r\n        // PASSO 1: DeepSeek gera o roteiro validado em JSON\r\n        // ------------------------------------------------------------------\r\n        let script: GeneratedScript\r\n        try {\r\n            script = await generateScript({\r\n                apiKey: apiKeys.deepseek,\r\n                briefing,\r\n                sceneCount,\r\n                isAnimeMode,\r\n                animeStyle,\r\n            })\r\n        } catch (err) {\r\n            console.error('Orchestrator: DeepSeek step failed', err)\r\n            throw new Error(`Falha ao gerar roteiro: ${err instanceof Error ? err.message : 'Erro desconhecido'}`)\r\n        }\r\n\r\n        // Inicializa resultados como pending\r\n        const sceneResults: SceneResult[] = script.scenes.map((scene) => ({\r\n            order: scene.order,\r\n            description: scene.description,\r\n            visualPrompt: scene.visualPrompt,\r\n            tone: scene.tone,\r\n            durationSeconds: scene.durationSeconds,\r\n            status: 'script_done',\r\n        }))\r\n\r\n        // ------------------------------------------------------------------\r\n        // PASSO 2: Leonardo.ai gera frames em paralelo por cena\r\n        // ------------------------------------------------------------------\r\n        const leonardoModel = selectLeonardoModel(animeStyle)\r\n        console.info(`Generating ${script.scenes.length} frames using Leonardo.ai...`)\r\n\r\n        const framePromises = script.scenes.map(async (scene, index) => {\r\n            const enrichedPrompt = enrichPromptForAnime(scene.visualPrompt, animeStyle)\r\n\r\n            try {\r\n                const frame = await generateFrame({\r\n                    apiKey: apiKeys.leonardo,\r\n                    prompt: enrichedPrompt,\r\n                    modelId: leonardoModel,\r\n                    width: imageOptions.width ?? 1024,\r\n                    height: imageOptions.height ?? 576,\r\n                    numImages: 1,\r\n                    seed: imageOptions.seed,\r\n                })\r\n                return { index, frame, error: null }\r\n            } catch (err) {\r\n                console.warn(`Orchestrator: Failed to generate frame for scene ${index + 1}`, err)\r\n                return { index, frame: null, error: err instanceof Error ? err.message : 'Erro na geração da imagem' }\r\n            }\r\n        })\r\n\r\n        const frameResults = await Promise.all(framePromises)\r\n        const failedScenes: number[] = []\r\n\r\n        for (const res of frameResults) {\r\n            const { index, frame, error } = res\r\n\r\n            if (error || !frame) {\r\n                sceneResults[index].status = 'error'\r\n                sceneResults[index].error = error ?? 'Erro desconhecido na geração de frame.'\r\n                failedScenes.push(sceneResults[index].order)\r\n            } else {\r\n                sceneResults[index].status = 'frame_done'\r\n                sceneResults[index].frame = frame\r\n            }\r\n        }\r\n\r\n        const totalDurationSeconds = sceneResults.reduce(\r\n            (acc, s) => acc + s.durationSeconds,\r\n            0,\r\n        )\r\n\r\n        console.info('Creation flow completed.', {\r\n            success: failedScenes.length === 0,\r\n            scenesGenerated: sceneResults.length,\r\n            failedCount: failedScenes.length,\r\n        })\r\n\r\n        return {\r\n            success: failedScenes.length === 0,\r\n            script,\r\n            scenes: sceneResults,\r\n            failedScenes,\r\n            totalDurationSeconds,\r\n        }\r\n    } catch (error) {\r\n        console.error('Orchestrator: Critical failure in creation flow', error)\r\n        throw error\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 629, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lenovo/Downloads/director-flow-studio/src/app/actions/generate.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { auth } from \"@clerk/nextjs/server\";\r\nimport { runCreationFlow } from \"@/services/ia/orchestrator\";\r\nimport { getSettings } from \"./settings\";\r\nimport { revalidatePath } from \"next/cache\";\r\n\r\nexport async function generateContent(formData: FormData) {\r\n    const { userId } = await auth();\r\n    if (!userId) throw new Error(\"Não autorizado\");\r\n\r\n    const briefing = formData.get(\"briefing\") as string;\r\n    const settings = await getSettings();\r\n\r\n    if (!settings || !settings.deepseekKey || !settings.leonardoKey) {\r\n        return {\r\n            success: false,\r\n            error: \"Por favor, configure suas chaves de API nas configurações antes de gerar.\"\r\n        };\r\n    }\r\n\r\n    try {\r\n        const result = await runCreationFlow({\r\n            briefing,\r\n            sceneCount: 3, // Default para teste\r\n            apiKeys: {\r\n                deepseek: settings.deepseekKey,\r\n                leonardo: settings.leonardoKey,\r\n            },\r\n            anime: {\r\n                enabled: settings.isAnimeMode,\r\n                style: (settings.animeStyle as any) || \"shonen\",\r\n            }\r\n        });\r\n\r\n        revalidatePath(\"/\");\r\n        return {\r\n            success: result.success,\r\n            data: result,\r\n            error: result.success ? null : \"Alguns frames falharam na geração.\"\r\n        };\r\n    } catch (error) {\r\n        console.error(\"Erro na geração:\", error);\r\n        return {\r\n            success: false,\r\n            error: error instanceof Error ? error.message : \"Erro interno no orquestrador.\"\r\n        };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;;;;;;;;;;;AAEO,eAAe,gBAAgB,QAAkB;IACpD,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,IAAA,2LAAI;IAC7B,IAAI,CAAC,QAAQ,MAAM,IAAI,MAAM;IAE7B,MAAM,WAAW,SAAS,GAAG,CAAC;IAC9B,MAAM,WAAW,MAAM,IAAA,gJAAW;IAElC,IAAI,CAAC,YAAY,CAAC,SAAS,WAAW,IAAI,CAAC,SAAS,WAAW,EAAE;QAC7D,OAAO;YACH,SAAS;YACT,OAAO;QACX;IACJ;IAEA,IAAI;QACA,MAAM,SAAS,MAAM,IAAA,wJAAe,EAAC;YACjC;YACA,YAAY;YACZ,SAAS;gBACL,UAAU,SAAS,WAAW;gBAC9B,UAAU,SAAS,WAAW;YAClC;YACA,OAAO;gBACH,SAAS,SAAS,WAAW;gBAC7B,OAAO,AAAC,SAAS,UAAU,IAAY;YAC3C;QACJ;QAEA,IAAA,+IAAc,EAAC;QACf,OAAO;YACH,SAAS,OAAO,OAAO;YACvB,MAAM;YACN,OAAO,OAAO,OAAO,GAAG,OAAO;QACnC;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,oBAAoB;QAClC,OAAO;YACH,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QACpD;IACJ;AACJ;;;IAzCsB;;AAAA,+OAAA"}}]
}